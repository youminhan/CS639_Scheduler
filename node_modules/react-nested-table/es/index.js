var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

import "react-table/react-table.css";
import './style.scss';

import React, { Component } from 'react';
import PropTypes from 'prop-types';
import ReactTable from 'react-table';
import ImageZoom from 'react-medium-image-zoom';
import _ from 'lodash';

var MIN_ROWS = 0;
var PAGE_SIZE = 50;

function uniqId() {
    return ('' + Date.now() + (Math.random() * 10 | 0)).substr(5);
}

/**
 * Get the width of text, used for adjusting column width on a table
 * @param {String} text the text that wants to get its width
 * @param {String} font the font style of current text
 * @returns {Number} the width (pixel)
 */
function getTextWidth(text) {
    var font = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'bold 18px sans-serif';

    var minWidth = 25;
    // re-use canvas object for better performance
    var canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement("canvas"));
    var context = canvas.getContext("2d");
    context.font = font;
    var metrics = context.measureText(text);
    return Math.max(metrics.width, minWidth);
}

function isArray(val) {
    return Array.isArray(val);
}

function isObject(val) {
    return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.constructor === Object;
}

function isImage(val) {
    if (typeof val !== 'string') {
        return false;
    }
    var fileExtension = val.split('.').pop();
    var IMAGE_EXTENSIONS = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'tiff'];
    return IMAGE_EXTENSIONS.indexOf(fileExtension) > -1;
}

function isHtml(val) {
    return typeof val === 'string' && val.split('.').pop().includes('htm');
}

/**
 * Render a table/iframe/list based on data
 * It will automatically change UI by the types of data
 * @param {Array/Object/String} data data needs to be rendered
 */
function renderByData(data, keyMaps, onCellDisplay) {
    if (!data) {
        return null;
    }

    if (isHtml(data)) {
        return React.createElement('iframe', { src: data, style: { height: "50vh", width: "100%" } });
    }

    if (isObject(data)) {
        data = [data];
    }

    if (isArray(data)) {
        var dataModel = data[0];

        // used for storing expanding keys in different rows
        var currentExpandedKeys = {};

        // render as a list if there is only String or Number in Array
        if (!isObject(dataModel) && !isArray(dataModel)) {
            return React.createElement(
                'ul',
                null,
                data.map(function (item, i) {
                    return React.createElement(
                        'li',
                        { key: 'nested_table_' + i },
                        item
                    );
                })
            );
        }

        var columns = dataToColumns(data, keyMaps, onCellDisplay, currentExpandedKeys);

        return React.createElement(ReactTable, {
            data: data,
            columns: columns,
            className: '-striped -highlight',
            minRows: 0,
            defaultPageSize: PAGE_SIZE,
            showPagination: data && data.length > PAGE_SIZE ? true : false,
            SubComponent: function SubComponent(row) {
                // get current active key which needs to be expanded (triggered by clicking on a td element)
                var currentExpandedKey = currentExpandedKeys[row.index];

                return React.createElement(
                    'div',
                    { className: 'react-nested-table-inner' },
                    React.createElement(
                        'h4',
                        { className: 'title' },
                        keyMaps[currentExpandedKey] || currentExpandedKey
                    ),
                    renderByData(row.original[currentExpandedKey], keyMaps, onCellDisplay)
                );
            }
            // onExpandedChange={(newExpanded, index, event) => {console.log('onExpand', newExpanded, index, event)}}
            , getTdProps: function getTdProps(state, rowInfo, column, instance) {
                return {
                    onClick: function onClick(e, handleOriginal) {
                        // used to identify which column is expanding
                        if (column.expander) {
                            currentExpandedKeys[rowInfo.index] = column.id;
                        }

                        // IMPORTANT! React-Table uses onClick internally to trigger
                        // events like expanding SubComponents and pivots.
                        // By default a custom 'onClick' handler will override this functionality.
                        // If you want to fire the original onClick handler, call the
                        // 'handleOriginal' function.
                        if (handleOriginal) {
                            handleOriginal();
                        }
                    }
                };
            }
        });
    }
}

/**
 * Transfer data to columns that is used for rendering table
 * @param {Array} data 
 * @returns {Array} an array of columns configuration
 */
function dataToColumns(data, keyMaps, onCellDisplay, currentExpandedKeys) {
    if (data && data.length) {
        var dataModel = data[0];

        return Object.keys(dataModel).map(function (key) {
            var currentData = dataModel[key];
            var defaultColumn = {
                Header: keyMaps[key] || key,
                accessor: key,
                width: getTextWidth(key)
            };

            if (isObject(currentData) || isArray(currentData) || isHtml(currentData)) {
                return {
                    expander: true,
                    Header: function Header() {
                        return React.createElement(
                            'strong',
                            null,
                            keyMaps[key] || key
                        );
                    },
                    width: 65,
                    id: key,
                    Expander: function Expander(_ref) {
                        var isExpanded = _ref.isExpanded,
                            rowInfo = _objectWithoutProperties(_ref, ['isExpanded']);

                        return React.createElement(
                            'div',
                            null,
                            isExpanded && currentExpandedKeys[rowInfo.index] === key ? React.createElement(
                                'span',
                                null,
                                '\u2299'
                            ) : React.createElement(
                                'span',
                                null,
                                '\u2295'
                            )
                        );
                    },
                    style: {
                        cursor: "pointer",
                        fontSize: 25,
                        padding: "0",
                        textAlign: "center",
                        userSelect: "none"
                    }
                };
            }

            if (onCellDisplay) {
                var column = onCellDisplay(key, currentData);
                if (column) {
                    return Object.assign({}, defaultColumn, column);
                }
            }

            if (isImage(currentData)) {
                return Object.assign({}, defaultColumn, {
                    Cell: function Cell(cellData) {
                        return React.createElement(ImageZoom, {
                            image: {
                                src: cellData.original[key],
                                alt: key,
                                className: 'image'
                            }
                        });
                    } });
            }

            return defaultColumn;
        });
    }
    return [{ Header: 'ID', accessor: 'id' }];
}

var ReactNestedTable = function (_Component) {
    _inherits(ReactNestedTable, _Component);

    function ReactNestedTable() {
        _classCallCheck(this, ReactNestedTable);

        return _possibleConstructorReturn(this, _Component.apply(this, arguments));
    }

    ReactNestedTable.prototype.render = function render() {
        return renderByData(this.props.data, this.props.headersMap, this.props.onCellDisplay);
    };

    return ReactNestedTable;
}(Component);

ReactNestedTable.defaultProps = {
    data: [],
    headersMap: {}
};

ReactNestedTable.propTypes = process.env.NODE_ENV !== "production" ? {
    /**
     * data, should be a json
     */
    data: PropTypes.array.isRequired,
    /**
     *  Mapping between data key and column header title for display
     */
    headersMap: PropTypes.object,
    onCellDisplay: PropTypes.func
} : {};

export default ReactNestedTable;